## 权限系统与管理
1. 为什么要进行权限控制？
虽然对于权限管理真正把关的是后端，但是如果前端不做权限控制，很多受限功能会被展示出来但是却又拒绝被访问，对于用户来说体验是不够好的。所以最好的优化方式是直接按照权限数据关闭那些对应功能的入口。此外，仍旧是对网站提供一些弱防护的。

2. 思路方向
前端做的权限控制大致是先接收后端发送的权限数据，然后将这个数据注入到应用中的模式，从而对页面的展示内容和导航逻辑进行控制。
登录权限，页面权限，内容权限

3. 登录权限控制
登录权限控制要做的事情,是实现哪些页面能被游客访问,哪些页面只有登录后才能被访问。因为Vue做的比较多，所以以此为例。直接的方式是利用路由配置和前置路由守卫，在需要登录访问的路由树下配置一个需要登录的属性，当用户即将跳转这些需要登录的页面时会调用路由守卫判断当前用户的登录状态（vuex存放等），登录就放行，没有登录就走定向到登录页面。

4. 页面权限控制
页面权限控制与路由权限直接关联。正常的做法是后端提前根据角色配置好该角色的路由权限列表。前端则配置静态路由和动态路由，静态路由就是不区分角色性质的部分，动态路由就是区分角色的部分。
用户登录后调用权限接口获取到权限列表并存储到storage（vuex，localStorage）中，根据这个列表从动态路由中过滤不允许访问的路由，然后添加到路由栈中（router.addRoute）
*由于vue-router 4废除了之前的router.addRoutes,换成了router.addRoute.每一次只能一个个添加路由信息,所以要将allow_routes遍历循环添加.*

注意：切换用户的时候，需要强制刷新页面或者清空路由实例中的路由栈。

！！！还有一种更简单的方式是动态导航的方式，在渲染导航栏的时候，路由数据是根据调取后端返回的数据来渲染的，就能够直接显示对应角色的导航。

5. 内容权限控制
页面权限控制它能做到让不同角色访问不同的页面,但对于一些颗粒度更小的项目,比如希望不同的角色都能进入页面,但要求看到的页面内容不一样,这就需要对内容进行权限控制了.
例子：在一个页面中，管理员可以增删查改，普通用户只能查
一种做法是，让后端在用户信息里增添一个权限编码字段。然后前端全局自定义一个快捷指令（vue），在区分角色类型的内容元素中，就可以通过对应需要的权限编码来判断是否有操作的权限。有权限的就在元素dom渲染上，没有则移除。
``` javascript
// 自定义全局指令
import router from './router';
import store from './store';

const app = createApp(App); //创建vue的根实例

app.directive('permission', {
  mounted(el, binding, vnode) {
    const permission = binding.value; // 获取权限值
    const page_name = router.currentRoute.value.name; // 获取当前路由名称
    const have_permissions = store.state.permission_list[page_name] || ''; // 当前用户拥有的权限
    if (!have_permissions.includes(permission)) {
      el.parentElement.removeChild(el); //不拥有该权限移除dom元素
    }
  },
});
```



2. 小程序和h5的区别 
[小程序 pk H5](https://www.woshipm.com/pd/1315132.html)

3. 前端优化24条建议
  1. 减少HTTP请求。一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。，真正下载数据的时间占比其实不高，建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数。
  2. 使用HTTP2。相较于HTTP1.1，HTTP具有解析速度更快，多路复用，首部压缩，紧急请求优先级高，流量控制，服务器推送等有点。
  3. 使用服务端渲染。
  4. 使用内容分发网络CDN。
  5. 将CSS放在文件头部，JS文件放在底部。CSS 执行会阻塞渲染，阻止 JS 执行。JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建。
  6. 使用字体图标 iconfont 代替图片图标。
  7. 善用缓存，不重复加载相同的资源。
  8. 压缩文件（webpack，gzip）
  9. 图片优化（延迟加载，响应式图片，降低图片质量利用CCS效果替代，使用webp图片）
  10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
  11. 减少重绘重排
  12. 使用事件委托
  13. 注意程序的局部性
  14. if-else 对比 switch，当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。
  15.  查找表。当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。
  16. 避免页面卡顿
  17. 使用 requestAnimationFrame 来实现视觉变化
  18. 使用 Web Workers
  19. 使用位操作
  20. 不要覆盖原生方法
  21. 降低 CSS 选择器的复杂性
  22. 使用 flexbox 而不是较早的布局模型
  23. 使用 transform 和 opacity 属性更改来实现动画
  24. 合理使用规则，避免过度优化。性能优化主要分为两类：加载时优化，运行时优化上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。
[前端优化24条](https://segmentfault.com/a/1190000022205291)

3. 前端优化35条军规
![雅虎35条军规](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/15/1653cde6a580cb29~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
[雅虎35条军规](https://juejin.cn/post/6844903657318645767)
